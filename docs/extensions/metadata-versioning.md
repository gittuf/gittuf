# Metadata Versioning and Backwards Compatibility

Last Modified: September 25, 2024

As gittuf is intended to be used in a distributed manner by developers
contributing to a repository, we need to have a plan in place for version skews.
It will inevitably be the case that different developers have different versions
of the client, and this can lead to unintended consequences with mismatched
metadata versions.

## What's Versioned

Currently, we version the following pieces:
* attestation predicates: individual in-toto attestation predicates are
  versioned in the predicate type URI
* gittuf implementation: the implementation itself is versioned and encompasses
  the behavior / workflows as well as the default versions of the metadata
  generated by the client at that version

As of now, the TUF-like metadata used for gittuf policy is not versioned for
its schema, which will be amended as part of this document. In summary, we can
expect to have the following pieces versioned:
* attestation predicates
* gittuf policy metadata
* gittuf implementation / behavior

## Version Compatibilities

There are several aspects of version compatibility to consider.

### Predicate Versions

Different clients (on different versions) may default to different versions of a
predicate for the same context. For example, Alice uses an older version of the
reference authorization predicate to approve a change. Bob wants to approve the
same change but his client defaults to a newer version of the predicate. His
client notices that there is already an authorization attestation for the change
created by Alice and tries to add his signature to the existing attestation.

#### Signing an older version of a predicate using a newer client

If the predicate is of the same major version, this should be allowed. The
validation of the predicate during the signing flow should use the validator for
the version in question.

TODO: major version drifts

#### Signing a newer version of a predicate using an older client

If the predicate is of the same major version, this should be allowed. The
client must skip validating the predicate, as the older client does not have the
appropriate validator for the predicate. The client must also print a warning to
the user to update their client.

TODO: major version drifts

### Policy Metadata Versions

We have a similar set of scenarios for policy metadata versions as predicate
versions.

#### Signing an older version of a policy file using a newer client

The newer client must reject signing an older version of the policy metadata.
Optionally, it may attempt to stage the same changes using the latest version of
the policy metadata. In this scenario, the original developer who made the
policy change will have to add their signature again.

#### Signing a newer version of a policy file using an older client

The older client may sign the policy metadata, though it may be unable to make
other changes to the schema. The user must be alerted to update their client.

### gittuf Implementation Versions

The gittuf implementation or client version conveys the behavior of gittuf
workflows it invokes. In that sense, this encompasses the version of the
predicate and policy metadata, as the client selects the version of metadata it
signs and consumes.

#### Verifying older version predicate or policy metadata using a newer client

Sometimes, a predicate version bump may be to include information required due
to a change in the verification workflow. In such contexts, we must be careful
to fail-closed if an older version of a predicate is used, as using the older
client may otherwise be used to bypass gittuf's protections.

It might be viable to accept an older predicate version if the active policy
does not rely on the added change. Further exploration is necessary.

Note: I think we still haven't sufficiently unentangled the versioning of the
implementation vs the predicates and metadata schemas. I think it's likely that
a major version bump to the implementation due to a behavioral change in the
verification workflow is likely to also require a major version bump for the
predicate type used to meet the corresponding policy. We could make this
explicit and effectively lock compatibility within a major version?

#### Verifying newer version predicate or policy metadata using an older client

The client must warn the user that an update is necessary. Updated policy could
mean the older client cannot verify some new rules, and is likely tied to a
major version bump as before.
