# gittuf on the Forge

Last Modified: October 21, 2024

gittuf can be deployed at the forge that all developers push changes to. This
instance of gittuf must behave differently from regular gittuf clients because
multiple developers may be pushing and fetching from the forge at any given
point in time.

## What are the responsibilities of gittuf at the forge?

The forge uses gittuf to:
* receive an update from a developer
* perform gittuf verification on the update
* make update available to all developers if gittuf verification succeeds
* serialize update handling so that the linearity of the RSL is maintained

## How can gittuf perform verification at the forge?

gittuf can perform verification in several ways at the server. The first option
is a simple pre-receive hook that is invoked every time an update is pushed to
the server. The hook is provided a summary of the changes to the RSL and the
updated Git reference, i.e., all the information necessary for gittuf
verification. If the verification is successful, the push is allowed to succeed.

The other option is to use a CI system or have gittuf verification implemented
in the server software itself.

## Where must gittuf clients send an update to?

A gittuf client pushing an update changes _two_ Git references: the reference
updated by the developer and changes to the RSL. The client must push both
changes
[atomically](https://git-scm.com/docs/git-push#Documentation/git-push.txt---no-atomic)
so that either both references are updated or neither at the forge.

The client, broadly speaking, has two options: either it pushes directly to the
forge's RSL and the updated reference, or it does not, instead pushing to
another namespace at the forge. Let us consider each.

### Pushing directly to the RSL and updated reference

As the push is atomic, the repository does not enter an invalid state where only
the RSL or the updated reference is updated. This option works well in low
traffic scenarios, where pushes are few and far between. This is because in the
case of multiple parallel pushes, verification may be invoked for each in
parallel.  This is the case for pre-receive hooks. The first one to succeed
"wins", updating the repository state and leading to the other pushes failing.
This is not ideal as gittuf verification scales by the number of RSL entries and
files modified in an update. Larger changes will, therefore, fail more due to
concurrent smaller changes. Note that Git implements a lock on its internal
store, but this does not block pushes prior to the hook invocation (TODO: test,
this is based off existing documentation).

If the invocation of verification is not via a pre-receive hook, the repository
can reject other new pushes when verifying one. This mechanism must also ensure
the RSL state and the updated reference are not exposed to clients until after
verification succeeds, as clients must not receive an unverified RSL entry.

### Pushing to staging namespaces in the repository

In this case, the gittuf client pushes to staging namespaces, such as
`refs/gittuf/staging/reference-state-log` and
`refs/gittuf/staging/<git-reference>`. The repository verification can be
triggered using any mechanism. As the staging area namespaces are consistently
generated by all gittuf clients, they act as an implicit lock to new pushes. A
gittuf client cannot push to the staging area when a prior push is being
verified.

If the verification succeeds, the verifying mechanism must update the actual RSL
and the updated reference. In addition, regardless of the status of
verification, the staging namespaces must be removed to allow other gittuf
clients to push to.

The staging namespace cannot be used with a pre-receive hook as it must reflect
a push in progress. The post-receive hook is a better fit if a Git server-side
hook is to be used.
