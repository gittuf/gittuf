# gittuf Versioning Policy

## Metadata

* **Number:** TBD
* **Title:** gittuf Versioning Policy
* **Implemented:** No
* **Withdrawn/Rejected:** No
* **Sponsors:** Aditya Sirish A Yelgundhalli (adityasaky)
* **Last Modified:** October 25, 2025

## Abstract

As gittuf is intended to be used in a distributed manner by developers
contributing to a repository, we need to have a plan in place for version skews.
It will inevitably be the case that different developers have different versions
of the client. And, different versions of the client may support different
versions of gittuf's policy and attestation schemas. If not handled with care,
this can lead to unintended consequences, including degraded security
guarantees.

## Specification

Currently, gittuf versions the following pieces:
* attestation predicates: individual in-toto attestation predicates are
  versioned in the predicate type URI; this is inherited from the in-toto
  attestation specification
* gittuf implementation: the implementation itself is versioned and encompasses
  the behavior / workflows as well as the default versions of the metadata
  generated by the client at that version

The gittuf policy metadata is not versioned for its schema, which will be
amended as part of this document. In summary, we intend to have the following
gittuf components versioned:
* attestation predicates
* gittuf policy metadata
* gittuf implementation and behavior

Note that all versioning follows semantic versioning.

### General Guidelines

Whenever a client encounters a newer metadata version than that supported by the
client, it must prompt the user to update the client. This is the case for minor
and patch version bumps as well.

### Client Workflows for Cross-Version Scenarios

There are several aspects of version compatibility to consider.

#### Attestation Predicate Versions

##### Signing an older version of a predicate using a newer client

If the predicate is of the same major version, the client must add a signature
to the existing attestation. The client must validate the predicate during the
signing flow using the validator for the version in question, i.e., the older
version. The user with the older client should be prompted, out of band, to
update their client.

If the predicate is from a previous major version, the client must generate an
equivalent predicate with the current major version. Out of band, the user who
generated the older predicate version must be prompted to update their client
and add their signature to the new attestation with the current predicate
version.

##### Signing a newer version of a predicate using an older client

If the predicate is of the same major version, the client must add a signature
to the existing attestation. The client cannot validate the predicate, as the
older client does not have the appropriate validator. The client must also print
a warning to the user to update their client.

If the predicate is of a higher major version, the client must abort and prompt
the user to update their client. This is because the client has no way to know
how the predicate has evolved, how the meaning of the predicate has changed (due
to the major version bump), and the implications of adding a signature on behalf
of the user.

##### Impact on verification

A newer client must support verifying using older predicate versions, including
lower major versions. E.g., a client that now supports v2 of a predicate must
continue supporting verification of changes attested to using v1 of a predicate.

An older client must support verifying changes attested to using newer predicate
versions of a major version supported by the client. E.g., the client may
support generating only v1.1 of a predicate, but must support verifying changes
attested to using v1.2 of the same predicate.

In some cases, the same change may be attested to using predicates of different
major versions. An older client that doesn't support the higher major version
cannot verify the change as it does not understand the newer predicate type. A
newer client **must not** use the predicates of the lower major version. In
other words, if a single change has predicates of multiple major versions, then
only attestations with the highest major version must be used during
verification.

##### Preventing rollbacks

It must be possible to set a minimum predicate major version in a repository,
following which all clients must generate attestations of that predicate type
with the specified major version (or higher). This must be defined in the
policy's root of trust metadata.

#### Policy Metadata Versions

While there are similar scenarios for policy metadata versions as predicate
versions, the client behavior is different. This is because all of the policy
metadata in a policy state are related to each other, unlike attestations which
exist in isolation. So, all metadata that makes up a policy state must have the
same major policy version.

##### Signing an older version of a policy file using a newer client

The newer client can sign an older minor or patch version of the policy
metadata.

##### Signing a newer version of a policy file using an older client

The older client may sign an older minor or patch version of the policy
metadata, though it is unable to make other changes to the schema. The user must
be alerted to update their client.

##### Creating new policy metadata

A developer's client must generate policy metadata using the same major policy
version as the latest policy state in the repository. If the client does not
support that major version, the policy metadata addition must be disallowed. If
the client supports a newer major version, the policy metadata addition may
proceed with a warning to the user that a newer version of the gittuf policy
metadata is available.

##### Impact on verification

gittuf's policy state verification must ensure all policy metadata in the state
have the same major version. In addition, a policy state's metadata must have
the same or higher major policy version than the previous policy state,
identified via the RSL. This prevents policy rollback attacks.

An older client must abort and fail gittuf verification when it encounters a
newer major version of the policy metadata. The user must be prompted to update
their client.

A newer client must continue verifying existing policy metadata of older major
versions.

##### Upgrading policy state to new major version

The root of trust key holders must use a newer version of the gittuf client to
translate the existing policy metadata to the latest major version supported by
the client. To avoid requiring all policy metadata to be re-signed by every
required developer, the root key holders may add their signature to all
metadata, rule files included, for the first policy state with the newer major
version.

More generally, this updates the policy state verification behavior to allow
signatures on any policy metadata by the root of key holders, even if they're
not part of the direct delegation on that policy metadata. Note that a threshold
of root key holders are required in such instances.

#### gittuf Implementation Versions

The gittuf implementation or client version conveys the behavior of gittuf
workflows it invokes. In that sense, this encompasses the version of the
predicate and policy metadata, as the client selects the version of metadata it
signs and consumes.

Significantly, the verification behavior of gittuf is only versioned via the
client's version, as this is not encoded as metadata itself. If the verification
behavior changes for existing policy and attestation predicate versions in a way
that a change that was previously allowed is now disallowed or vice versa, the
implementation's major version must be bumped. The gittuf client may check for
the existance of a newer version and inform the user. The client must not
attempt to update itself.

## Motivation

Different clients (on different versions) may default to different versions of a
predicate for the same context. For example, Alice may use an older version of
the reference authorization predicate to approve a change. Bob, who wants to
approve the same change, may have a newer version of the gittuf client which
uses a newer version of the predicate. Similarly, Alice may want to amend a
policy file that was last modified by Bob, and thus is of a newer version
unsupported by Alice's client. Handling these types of version mismatches is
imperative to ensure a developer using an older client does not cause
downgrade-style attacks, where the repository's metadata is rolled back to an
older version with fewer security guarantees.

## Reasoning

This GAP introduces ideas that balance security and usability. Being very strict
with policy version changes can lead to constant incompatibilities and break
developers' workflows.

## Backwards Compatibility

This GAP does not have impact on backwards compatibility of the existing gittuf
design and implementation. Indeed, the GAP introduces granular versioning of
metadata and behavior, which impacts how gittuf handles backwards compatibility
going forward.

## Security

The GAP considers the impact of mixed versioning for attestation predicates and
the policy metadata. Generally, the GAP proposes mechanisms to prevent rollback
attacks for both types of metadata. In addition, the GAP ensures clients fail in
actions that modify or verify metadata the client does not understand. This
ensures that an older client does not allow a change that would be prevented
with newer security features the client does not understand.

## Prototype Implementation

Some of the changes proposed in this GAP such as policy metadata versioning have
been added to the gittuf implementation.
